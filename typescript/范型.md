# j

## 范型

避免代码重复，创建可重复使用的类型

```ts
type Add<T> = (a: T, b: T) => T

const addNumbers: Add<number> = (a, b) => a + b

const addStrings: Add<string> = (a, b) => a + b
```

## Pick<Type, Keys>

从 Type 中选出属性集 Keys 来创建一个轻量的新的类型，keys 为一个字符串字面量或者字符串字面量的联合，且 keys 中的值必须为 Type 中的健

```ts
type User = {
  name: string
  age: number
  sexy: string
  address: string
}

type BasicUser = Pick<User, 'name' | 'age'>

// type BasicUser = {
//   name: string
//   age: number
// }
```

## Omit<Type, keys>

Type 和 keys 的关系同 Pick，只是和 Pick 不同的是，Omit 是从 Type 中省略 Keys 指定的属性，用于从对象中删除某些属性并保留其他属性

```ts
type User = {
  name: string
  age: number
  sexy: string
  address: string
}

type BasicUser = Omit<User, 'name' | 'age'>

// type BasicUser = {
//   sexy: string
//   address: string
// }
```

## Partial<Type>

针对 Type 类型构造一个新的所有属性皆为可选的类型

```ts
type User = {
  name: string
  age: number
  sexy: string
}

type PartialUser = Partial<User>

// type PartialUser = {
//   name?: string
//   age?: number
//   sexy?: string
// }
```

## Required<Type>

针对 Type 类型构造一个新的所有属性皆为必填的类型，可以被用来确保在一个类型中没有可选属性出现。

```ts
type User = {
  name: string
  age?: number
  sexy?: string
}

type RequiredUser = Required<User>

// type PartialUser = {
//   name: string
//   age: number
//   sexy: string
// }
```

## ReadOnly<Type>

针对 Type 类型构造一个所有属性仅可读不可写的类型

```ts
type User = {
  name: string
  age?: number
  sexy?: string
}

type ReadOnly = ReadOnly<User>

const zhang: ReadOnly = {
  name: '张',
}

zhang.name = '章'
// Cannot assign to 'name' because it is a read-only property.
```

## ReturnType<Type>

从一个函数类型的返回类型构建一个类型，一般用于基于外来库的函数类型，且希望基于它们建立自定义类型时

```ts
import axios from 'axios'

type Response = ReturnType<typeof axios>

function callAPI(): Response {
  return axios('url')
}
```
