# 类型

## 原始类型

> 原始类型指非对象且没有方法的数据类型

- string
- number
- boolean
- bigint
- undefined
- symbol
- ~~null~~（null 是一个伪原始类型，它在 js 中实际上是一个对象，且所有的结构化类型都是通过 null 原型链派生而来）

### bigint

较大的数字，与 number 类型不兼容

```ts
let big: bigint = 100n
```

### undefined

缺省、为定义的属性

## 数组

### 元祖类型（Tuple）

元祖最重要的特性是可以限制数组元素的个数和类型，适合用于实现多值返回

常用的`useState`的返回值就是一个元祖例子

```ts
const [num, setNum] = useState(1)
```

限定返回值的个数以及 num 和 setNum 的类型

## 其他类型

### void

如果函数没有返回值，类型为 void

## 类型断言

笃定某个值的类型，而不采用 ts 推测出的类型，则可以用类型断言，在类型层面强制类型转换

约束条件：父子、子父类型之间可以使用类型断言进行转换（？）

```ts
const arrayNumber: number[] = [1, 2, 3, 4]
// 主观意识上知道返回结果一定为number类型，对于ts而言并不知晓逻辑，所以存在返回值为undefined的可能，所以通过类型断言强制转换类型

// 类型断言1: 用as语法做类型断言，强制结果为number类型
const greaterThan: number = arrayNumber.find(num => num > 2) as number

// 类型断言2: 用<类型>做类型断言
const greaterThan: number = <number>arrayNumber.find(num => num > 2)
```

## 类型拓宽

指定了初始值但没显示的指明类型注解，那么被推断出来的类型就是初始值字面量类型的父级类型

一般对于 null 和 undefined，使用 let 直接定义为初始值时，他们拓宽后的类型为 any

```ts
let x = null // 类型拓宽成 any
let y = undefined // 类型拓宽成 any
```

## this

ts 中需要显示指明 this 的类型，函数中只需要在第一个参数中声明 this 类型即可

```ts
function say(this: Window, name: string) {
  console.log(this)
  console.log(name)
}

window.say = say
window.say('hi') // window hi
```

显式注解函数中的 this 类型，它表面上占据了第一个形参的位置，但并不意味着函数真的多了一个参数，因为 TypeScript 转译为 JavaScript 后，“伪形参” this 会被抹掉，这算是 TypeScript 为数不多的特有语法

## 函数重载

js 可以拥有不同类型的参数和返回值，通过函数重载可以精确描述参数与返回值类型的约束关系

函数重载列表的各个成员必须是函数实现的子集

```ts
function convert(x: string): number
function convert(x: number): string
function convert(x: null): -1
function convert(x: number | string | null): number | string | -1 {
  if (typeof x === 'string') {
    return Number(x)
  } else if (typeof x === 'number') {
    return String(x)
  }
  return -1
}

const a = convert(1) // string
const b = convert('1') // number
const c = convert(null) // -1
```

TypeScript 会从上到下查找函数重载列表中与入参类型匹配的类型，并优先使用第一个匹配的重载定义
