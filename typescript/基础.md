# 类型

## 原始类型

> 原始类型指非对象且没有方法的数据类型

- string
- number
- boolean
- bigint
- undefined
- symbol
- ~~null~~（null 是一个伪原始类型，它在 js 中实际上是一个对象，且所有的结构化类型都是通过 null 原型链派生而来）

### bigint

较大的数字，与 number 类型不兼容

```ts
let big: bigint = 100n
```

### undefined

缺省、为定义的属性

## 数组

### 元祖类型（Tuple）

元祖最重要的特性是可以限制数组元素的个数和类型，适合用于实现多值返回

常用的`useState`的返回值就是一个元祖例子

```ts
const [num, setNum] = useState(1)
```

限定返回值的个数以及 num 和 setNum 的类型

## 其他类型

### void

如果函数没有返回值，类型为 void

## 类型断言

笃定某个值的类型，而不采用 ts 推测出的类型，则可以用类型断言，在类型层面强制类型转换

约束条件：父子、子父类型之间可以使用类型断言进行转换（？）

```ts
const arrayNumber: number[] = [1, 2, 3, 4]
// 主观意识上知道返回结果一定为number类型，对于ts而言并不知晓逻辑，所以存在返回值为undefined的可能，所以通过类型断言强制转换类型

// 类型断言1: 用as语法做类型断言，强制结果为number类型
const greaterThan: number = arrayNumber.find(num => num > 2) as number

// 类型断言2: 用<类型>做类型断言
const greaterThan: number = <number>arrayNumber.find(num => num > 2)
```

## 类型拓宽

指定了初始值但没显示的指明类型注解，那么被推断出来的类型就是初始值字面量类型的父级类型

一般对于 null 和 undefined，使用 let 直接定义为初始值时，他们拓宽后的类型为 any

```ts
let x = null // 类型拓宽成 any
let y = undefined // 类型拓宽成 any
```

## this

ts 中需要显示指明 this 的类型，函数中只需要在第一个参数中声明 this 类型即可

```ts
function say(this: Window, name: string) {
  console.log(this)
  console.log(name)
}

window.say = say
window.say('hi') // window hi
```

显式注解函数中的 this 类型，它表面上占据了第一个形参的位置，但并不意味着函数真的多了一个参数，因为 TypeScript 转译为 JavaScript 后，“伪形参” this 会被抹掉，这算是 TypeScript 为数不多的特有语法

## 函数重载

js 可以拥有不同类型的参数和返回值，通过函数重载可以精确描述参数与返回值类型的约束关系

函数重载列表的各个成员必须是函数实现的子集

```ts
function convert(x: string): number
function convert(x: number): string
function convert(x: null): -1
function convert(x: number | string | null): number | string | -1 {
  if (typeof x === 'string') {
    return Number(x)
  } else if (typeof x === 'number') {
    return String(x)
  }
  return -1
}

const a = convert(1) // string
const b = convert('1') // number
const c = convert(null) // -1
```

TypeScript 会从上到下查找函数重载列表中与入参类型匹配的类型，并优先使用第一个匹配的重载定义，所以想优先匹配的类型，需要放到最前面

## 类型谓词（is）

通过`参数名 is 类型`格式可以明确表明参数的类型

```ts
function add(n): n is number {
  return n + 1
}
```

## 类

派生类通常被称作子类，基类也称作超类（父类）

派生类中如果含有构造函数（constructor），则必须调用`super()`，以此调用基类的构造函数

extends：子类可以通过 extends 继承基类的属性和方法

可见修饰符：

- public 修饰在任何地方可见、公有的属性和方法
- private 修饰仅在同一类中可见、私有的属性和方法
- protected 修饰仅在类自身及子类中可见、受保护的属性和方法

public 是公开的，可以被访问和修改，private 是私有的，只有在其定义的类中可以访问和修改，protected 是受保护的，只能在类自身及子类中能被访问和修改

只读修饰符：readonly，针对属性而言，不可修改值，仅能读取值

如果只读修饰符和可见性修饰符同时出现，我们需要将只读修饰符写在可见修饰符后面

static：定义静态属性和方法

## interface 与 type

- interface：接口类型
- type：类型别名

接口类型可以重复定义，属性会叠加，但不能出现重复的属性名；类型别名不行，会提示 ts（2300）错误；此外接口类型可以用 extends 继承属性，但接口类型只能声明对象，类型别名可以声明元组、联合类型、交叉类型、原始类型及对象，还能提取接口属性类型

```ts
interface Language {
  id: string
}
interface Language {
  name: string
}
const lang: Language = {
  id: '1',
  name: 'name',
}
```

```ts
type MixedType = string | number
type IntersectionType = { id: number; name: string } & {
  age: number
  name: string
}
type AgeType = ProgramLanguage['age']
```

合并接口类型时，如果有相同属性但其类型不同，则变为无用类型；如果有相同属性但其中一个属性为子类型，合并后属性的类型则为子类型

```ts
type IntersectionTypeConfict = { id: number; name: string } & {
  age: number
  name: number
}
const mixedConflict: IntersectionTypeConfict = {
  id: 1,
  name: 2, // ts(2322) 错误，'number' 类型不能赋给 'never' 类型
  age: 2,
}
```

```ts
type IntersectionTypeConfict = { id: number; name: 2 } & {
  age: number
  name: number
}

let mixedConflict: IntersectionTypeConfict = {
  id: 1,
  name: 2, // ok
  age: 2,
}

mixedConflict = {
  id: 1,
  name: 22, // '22' 类型不能赋给 '2' 类型
  age: 2,
}
```

合并联合类型时为一个交叉类型，这个交叉类型需要同时满足不同的联合类型限制，也就是他是所有联合类型的子集

```ts
type UnionA = 'px' | 'em' | 'rem' | '%'
type UnionB = 'vh' | 'em' | 'rem' | 'pt'
type IntersectionUnion = UnionA & UnionB
const intersectionA: IntersectionUnion = 'em' // ok
const intersectionB: IntersectionUnion = 'rem' // ok
const intersectionC: IntersectionUnion = 'px' // ts(2322)
const intersectionD: IntersectionUnion = 'pt' // ts(2322)
```

联合操作符`|`的优先级低于交叉操作符`&`，同样，我们可以通过使用小括弧 () 来调整操作符的优先级

类型缩减，TypeScript 把字面量类型、枚举成员类型缩减掉，只保留原始类型、枚举类型等父类型，这是合理的“优化“

```ts
type URStr = 'string' | string // 类型是 string
type URNum = 2 | number // 类型是 number
type URBoolen = true | boolean // 类型是 boolean
enum EnumUR {
  ONE,
  TWO,
}
type URE = EnumUR.ONE | EnumUR // 类型是 EnumUR
```

但是缩减后 IDE 只会提示缩减后的类型，不会把字面量类型展示出来，TypeScript 官方针对此提供了一个方法：只需要给父类型添加`& {}`即可

```ts
type BorderColor = 'black' | 'red' | 'green' | 'yellow' | 'blue' | string // 类型缩减成 string
```

```ts
type BorderColor = 'black' | 'red' | 'green' | 'yellow' | 'blue' | string & {} // 字面类型都被保留
```
