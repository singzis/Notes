# 类型

https://juejin.cn/post/6844904055039344654

## 原始类型

> 原始类型指非对象且没有方法的数据类型

- string
- number
- boolean
- bigint
- undefined
- symbol
- ~~null~~（null 是一个伪原始类型，它在 js 中实际上是一个对象，且所有的结构化类型都是通过 null 原型链派生而来）

### bigint

较大的数字，与 number 类型不兼容

```ts
let big: bigint = 100n
```

### undefined

缺省、为定义的属性

### any

any可以赋值给除了never之外的任意类型，其他类型也能赋值给any类型

### never

never可以赋值给任何其他类型，但不能被任意其他类型赋值

### unknown

不能把unknown赋值给any之外的类型，其他任意类型都可以赋值给unknown类型

### void、unll、undefined

void类型仅可以赋值给any和unknown类型，仅any、never和unknown类型可以赋值给void类型

null和undefined类型仅能赋值给any和unknown类型，仅any和nerve类型可以赋值给null和undefined类型

## 数组

### 元祖类型（Tuple）

元祖最重要的特性是可以限制数组元素的个数和类型，适合用于实现多值返回

常用的`useState`的返回值就是一个元祖例子

```ts
const [num, setNum] = useState(1)
```

限定返回值的个数以及 num 和 setNum 的类型

## 其他类型

### void

如果函数没有返回值，类型为 void

## 类型断言

笃定某个值的类型，而不采用 ts 推测出的类型，则可以用类型断言，在类型层面强制类型转换

约束条件：父子、子父类型之间可以使用类型断言进行转换（？）

```ts
const arrayNumber: number[] = [1, 2, 3, 4]
// 主观意识上知道返回结果一定为number类型，对于ts而言并不知晓逻辑，所以存在返回值为undefined的可能，所以通过类型断言强制转换类型

// 类型断言1: 用as语法做类型断言，强制结果为number类型
const greaterThan: number = arrayNumber.find(num => num > 2) as number

// 类型断言2: 用<类型>做类型断言
const greaterThan: number = <number>arrayNumber.find(num => num > 2)
```

## 类型拓宽

指定了初始值但没显示的指明类型注解，那么被推断出来的类型就是初始值字面量类型的父级类型

一般对于 null 和 undefined，使用 let 直接定义为初始值时，他们拓宽后的类型为 any

```ts
let x = null // 类型拓宽成 any
let y = undefined // 类型拓宽成 any
```

## this

ts 中需要显示指明 this 的类型，函数中只需要在第一个参数中声明 this 类型即可

```ts
function say(this: Window, name: string) {
  console.log(this)
  console.log(name)
}

window.say = say
window.say('hi') // window hi
```

显式注解函数中的 this 类型，它表面上占据了第一个形参的位置，但并不意味着函数真的多了一个参数，因为 TypeScript 转译为 JavaScript 后，“伪形参” this 会被抹掉，这算是 TypeScript 为数不多的特有语法

## 函数重载

js 可以拥有不同类型的参数和返回值，通过函数重载可以精确描述参数与返回值类型的约束关系

函数重载列表的各个成员必须是函数实现的子集

```ts
function convert(x: string): number
function convert(x: number): string
function convert(x: null): -1
function convert(x: number | string | null): number | string | -1 {
  if (typeof x === 'string') {
    return Number(x)
  } else if (typeof x === 'number') {
    return String(x)
  }
  return -1
}

const a = convert(1) // string
const b = convert('1') // number
const c = convert(null) // -1
```

TypeScript 会从上到下查找函数重载列表中与入参类型匹配的类型，并优先使用第一个匹配的重载定义，所以想优先匹配的类型，需要放到最前面

## 类型谓词（is）

通过`参数名 is 类型`格式可以明确表明参数的类型

```ts
function add(n): n is number {
  return n + 1
}
```

## 类

派生类通常被称作子类，基类也称作超类（父类）

派生类中如果含有构造函数（constructor），则必须调用`super()`，以此调用基类的构造函数

extends：子类可以通过 extends 继承基类的属性和方法

可见修饰符：

- public 修饰在任何地方可见、公有的属性和方法
- private 修饰仅在同一类中可见、私有的属性和方法
- protected 修饰仅在类自身及子类中可见、受保护的属性和方法

public 是公开的，可以被访问和修改，private 是私有的，只有在其定义的类中可以访问和修改，protected 是受保护的，只能在类自身及子类中能被访问和修改

只读修饰符：readonly，针对属性而言，不可修改值，仅能读取值

如果只读修饰符和可见性修饰符同时出现，我们需要将只读修饰符写在可见修饰符后面

static：定义静态属性和方法

## interface 与 type

- interface：接口类型
- type：类型别名

接口类型可以重复定义，属性会叠加，但不能出现重复的属性名；类型别名不行，会提示 ts（2300）错误；此外接口类型可以用 extends 继承属性，但接口类型只能声明对象，类型别名可以声明元组、联合类型、交叉类型、原始类型及对象，还能提取接口属性类型

```ts
interface Language {
  id: string
}
interface Language {
  name: string
}
const lang: Language = {
  id: '1',
  name: 'name',
}
```

```ts
type MixedType = string | number
type IntersectionType = { id: number; name: string } & {
  age: number
  name: string
}
type AgeType = ProgramLanguage['age']
```

合并接口类型时，如果有相同属性但其类型不同，则变为无用类型；如果有相同属性但其中一个属性为子类型，合并后属性的类型则为子类型

```ts
type IntersectionTypeConfict = { id: number; name: string } & {
  age: number
  name: number
}
const mixedConflict: IntersectionTypeConfict = {
  id: 1,
  name: 2, // ts(2322) 错误，'number' 类型不能赋给 'never' 类型
  age: 2,
}
```

```ts
type IntersectionTypeConfict = { id: number; name: 2 } & {
  age: number
  name: number
}

let mixedConflict: IntersectionTypeConfict = {
  id: 1,
  name: 2, // ok
  age: 2,
}

mixedConflict = {
  id: 1,
  name: 22, // '22' 类型不能赋给 '2' 类型
  age: 2,
}
```

合并联合类型时为一个交叉类型，这个交叉类型需要同时满足不同的联合类型限制，也就是他是所有联合类型的子集

```ts
type UnionA = 'px' | 'em' | 'rem' | '%'
type UnionB = 'vh' | 'em' | 'rem' | 'pt'
type IntersectionUnion = UnionA & UnionB
const intersectionA: IntersectionUnion = 'em' // ok
const intersectionB: IntersectionUnion = 'rem' // ok
const intersectionC: IntersectionUnion = 'px' // ts(2322)
const intersectionD: IntersectionUnion = 'pt' // ts(2322)
```

联合操作符`|`的优先级低于交叉操作符`&`，同样，我们可以通过使用小括弧 () 来调整操作符的优先级

类型缩减，TypeScript 把字面量类型、枚举成员类型缩减掉，只保留原始类型、枚举类型等父类型，这是合理的“优化“

```ts
type URStr = 'string' | string // 类型是 string
type URNum = 2 | number // 类型是 number
type URBoolen = true | boolean // 类型是 boolean
enum EnumUR {
  ONE,
  TWO,
}
type URE = EnumUR.ONE | EnumUR // 类型是 EnumUR
```

但是缩减后 IDE 只会提示缩减后的类型，不会把字面量类型展示出来，TypeScript 官方针对此提供了一个方法：只需要给父类型添加`& {}`即可

```ts
type BorderColor = 'black' | 'red' | 'green' | 'yellow' | 'blue' | string // 类型缩减成 string
```

```ts
type BorderColor = 'black' | 'red' | 'green' | 'yellow' | 'blue' | (string & {}) // 字面类型都被保留
```

## 枚举

命名常量的集合

创建格式： enum + 枚举名字 + {}

```ts
enum Day {
  SUNDAY,
  MONDAY,
  TUESDAY,
  WEDNESDAY,
  THURSDAY,
  FRIDAY,
  SATURDAY,
}
```

使用方式：枚举名字.常量名字

```ts
Day.SUNDAY
```

JavaScript 中其实并没有与枚举类型对应的原始实现，而 TypeScript 转译器会把枚举类型转译为一个属性为常量、命名值从 0 开始递增数字映射的对象，在功能层面达到与枚举一致的效果，但可以改变初始递增的值

```ts
enum Day {
  SUNDAY = 1, // 从 1 开始递增
  MONDAY,
  TUESDAY,
  WEDNESDAY,
  THURSDAY,
  FRIDAY,
  SATURDAY,
}
```

也可以给常量指定任意类型、任意起始的数值，其后未显示指定值的成员会递增加 1，但要注意给其中某个变量指定值时别出现重复的情况，比如

```ts
enum Day {
  SUNDAY,
  MONDAY,
  TUESDAY,
  WEDNESDAY,
  THURSDAY,
  FRIDAY,
  SATURDAY = 5, // FRIDAY 已经被默认指为5le
}
```

也可以给常量指定为字符串字面量的值

```ts
enum Day {
  SUNDAY = 'sunday', // 后续从 0 开始递增
  // ...
}
```

枚举和其他任何枚举、类型都不可比较，除了数字枚举可以与数字类型比较，但是数字枚举极其不稳定

枚举成员和枚举类型之间的关系分两种情况： 如果枚举的成员同时包含字面量和非字面量枚举值，枚举成员的类型就是枚举本身（枚举类型本身也是本身的子类型）；如果枚举成员全部是字面量枚举值，则所有枚举成员既是值又是类型

```ts
enum Day {
  SUNDAY,
  MONDAY,
}

enum MyDay {
  SUNDAY,
  MONDAY = Day.MONDAY,
}

const mondayIsDay: Day.MONDAY = Day.MONDAY // 字面量枚举成员既是值，也是类型
const mondayIsSunday = MyDay.SUNDAY // 类型是 MyDay，MyDay.SUNDAY 仅仅是值
const mondayIsMyDay2: MyDay.MONDAY = MyDay.MONDAY // ts(2535)，MyDay 包含非字面量值成员，所以 MyDay.MONDAY 不能作为类型
```

通过添加 const 修饰符定义常量枚举

```ts
const enum Day {
  SUNDAY,
  MONDAY,
}
```

## declare

用以描述在其他地方定义过的变量和类型

## 泛型

- 定义：预先定义函数、接口或者类的时候，不预先定义数据的类型，而是在使用时再指定数据类型
- 目的：有效约束类型成员之间的关系，避免代码重复，创建可重复使用的类型

```ts
type Add<T> = (a: T, b: T) => T

const addNumbers: Add<number> = (a, b) => a + b

const addStrings: Add<string> = (a, b) => a + b
```

使用泛型创建 react 组件：

```ts
function Test<P>(props: { props1: string }) {
  return <div></div>
}

// 使用组件
;<Test<{ name: string }> props1="test" />
```

## Pick<Type, Keys>

从 Type 中选出属性集 Keys 来创建一个轻量的新的类型，keys 为一个字符串字面量或者字符串字面量的联合，且 keys 中的值必须为 Type 中的健

```ts
type User = {
  name: string
  age: number
  sexy: string
  address: string
}

type BasicUser = Pick<User, 'name' | 'age'>

// type BasicUser = {
//   name: string
//   age: number
// }
```

## Omit<Type, keys>

Type 和 keys 的关系同 Pick，只是和 Pick 不同的是，Omit 是从 Type 中省略 Keys 指定的属性，用于从对象中删除某些属性并保留其他属性

```ts
type User = {
  name: string
  age: number
  sexy: string
  address: string
}

type BasicUser = Omit<User, 'name' | 'age'>

// type BasicUser = {
//   sexy: string
//   address: string
// }
```

## Partial<Type>

针对 Type 类型构造一个新的所有属性皆为可选的类型

```ts
type User = {
  name: string
  age: number
  sexy: string
}

type PartialUser = Partial<User>

// type PartialUser = {
//   name?: string
//   age?: number
//   sexy?: string
// }
```

## Required<Type>

针对 Type 类型构造一个新的所有属性皆为必填的类型，可以被用来确保在一个类型中没有可选属性出现。

```ts
type User = {
  name: string
  age?: number
  sexy?: string
}

type RequiredUser = Required<User>

// type PartialUser = {
//   name: string
//   age: number
//   sexy: string
// }
```

## ReadOnly<Type>

针对 Type 类型构造一个所有属性仅可读不可写的类型

```ts
type User = {
  name: string
  age?: number
  sexy?: string
}

type ReadOnly = ReadOnly<User>

const zhang: ReadOnly = {
  name: '张',
}

zhang.name = '章'
// Cannot assign to 'name' because it is a read-only property.
```

## ReturnType<Type>

从一个函数类型的返回类型构建一个类型，一般用于基于外来库的函数类型，且希望基于它们建立自定义类型时

```ts
import axios from 'axios'

type Response = ReturnType<typeof axios>

function callAPI(): Response {
  return axios('url')
}
```

## 类型兼容

判断两个类是否兼容时，可以完全忽略构造函数及静态属性和方法是否兼容，只需要比较实例的属性和方法是否兼容，如果两个类包含私有的和受保护的属性及方法，则仅当这些属性和方法源自同一个类，才会兼容

```ts
class C1 {
  name = '1'
  private id = '1'
  protected age = 30
}
class C2 {
  name = '2'
  private id = '1'
  protected age = 30
}
let c1: C1
let c2: C2
c1 = c2 // ts(2322)
c2 = c1 // ts(2322)

class D {
  private id = '1'
  protected age = 30
}

class D1 extends D {
  name = '1'
  static gender = 'd1'
}
class D2 extends D {
  name = '2'
  static gender = 'd2'
}

let d1: D1
let d2: D2

d1 = d2 // ok
d2 = d1 // ok
```
