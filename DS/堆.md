特殊树，具备以下特点：
- 堆是一个完全二叉树
- 堆中每一个节点的值都必须大于等于（或小于等于）其子树节中每个节点的值

分类：
- 最大堆：顶部的值最大
- 最小堆：顶部的值最小

做为完全二叉树，可以通过数组实现堆的存储，数组中下标为 i 的节点的左子节点，就是下标为 i∗2 的节点，右子节点就是下标为 i∗2+1 的节点，父节点就是下标为 i / 2（向下取整）的节点

堆具备的操作：
- 插入
- 删除

在操作过程中，需要满足堆的特性，即需要对堆进行堆化，使其重新满足要求

堆的操作
```ts
class Heap {
    a: unknown[] // 存储堆数据的数组，从1开始
    n: number // 堆可以存储的最大值
    count: number // 堆中已经存储的数据个数

    constructor(capacity: number) {
        this.a = new Array(capacity + 1)
        this.n = capacity
        this.count = 0
    }

    swap(a: unknown[], a: number, b: number) {
		// 交换
    }

    insert(data: unknown) {
        if (this.count >= this.n) {
            return // 满了
        }

        this.count++
        this.a[this.count] = data

        let i = this.count
        while ((i >> 1) > 0 && this.a[i] > this.a[(i >> 1)]) {
            this.swap(this.a, i, (i >> 1))
            i = (i >> 1)
        }
    }

    removeMax() {
        // 删除堆顶最大元素
        if (this.count === 0) {
            return -1 // 没有数据
        }

        this.a[1] = this.a[this.count]
        this.count--
        this.heapify(this.a, this.count, 1)
    }

    heapify(a: unknown[], m: number, n: number) {
        // 自上往下堆化
        let i = n
        while (true) {
            let max = i
            const half = (i >> 1)
            if (half <= m && a[i] < a[i * 2]) {
                max = i * 2
            }
            if (half + 1 <= m && a[max] < a[i * 2 + 1]) {
                max = i * 2 + 1
            }
            if (max === i) {
                break
            }
            this.swap(a, i, max)
            i = max
        }
    }
}
```

## 堆的运用

大小堆适用场景：
- 优先队列
	- 说明：通过最小堆来维护优先级问题，堆顶就是优先级最高的数据
	- 合并有序小文件为有序大文件
		- 依次从各个小文件中取出最小的数据，合成一个堆，堆顶就是最小值，取出最小值插入大文件，然后从最小值对应的文件再取出一个值插入堆中，堆化后再取最小值插入大文件，依次执行，直到所有文件被插完
	- 定时器
		- 通过堆维护一个定时器，堆顶是最先执行的，通过堆顶的数据的执行时间与当前时间做差值得到T，从当前开始倒计时T后，就执行堆顶的数据，然后重新堆化计算新的T，依次直到所有定时器数据执行完毕
- top k
	- 说明：用最小堆实现，取所有数据中最大的k个数组成一个最小堆，堆顶则是第k大的数据，如果有新的数据插入进来，今需要和堆顶的数据比较，如果大于堆顶数据，则删除堆顶，插入新数，重新堆化，否则不做处理
- 求中位数