树的结构
```ts
class TreeNode {
  value: unknown
  left: TreeNode | null
  right: TreeNode | null

  constructor(value: unknown) {
    this.value = value
    this.left = null
    this.right = null
  }
}

//function TreeNode(value, left, right) {
//    this.value = value
//    this.left = left
//    this.right = right
//}

function preOrderRecursion(root: TreeNode) {
  function preOrderRecursionTree(root: TreeNode | null, result: unknown[]) {
    if (root !== null) {
      result.push(root.value)
      preOrderRecursionTree(root.left, result)
      preOrderRecursionTree(root.right, result)
    }
  }

  const result: unknown[] = []
  preOrderRecursionTree(root, result)
  return result
}

function preOrderTraversal(root: TreeNode) {
  const result: unknown[] = []
  const stack: TreeNode[] = []
  let cur: TreeNode | null = root
  while (cur !== null || stack.length !== 0) {
    while (cur !== null) {
      stack.push(cur)
      result.push(cur.value)
      cur = cur.left
    }
    cur = stack.pop() as TreeNode
    cur = cur.right
  }
  return result
}

function inOrderRecursion(root: TreeNode) {
  function inOrderRecursionTree(root: TreeNode | null, result: unknown[]) {
    if (root !== null) {
      inOrderRecursionTree(root.left, result)
      result.push(root.value)
      inOrderRecursionTree(root.right, result)
    }
  }

  const result: unknown[] = []
  inOrderRecursionTree(root, result)
  return result
}

function inOrderTraversal(root: TreeNode) {
  const result: unknown[] = []
  const stack: TreeNode[] = []
  let cur: TreeNode | null = root
  while (cur !== null || stack.length !== 0) {
    while (cur !== null) {
      stack.push(cur)
      cur = cur.left
    }

    cur = stack.pop() as TreeNode
    result.push(cur.value)
    cur = cur.right
  }
  return result
}

function postOrderRecursion(root: TreeNode) {
  function postOrderRecursionTree(root: TreeNode | null, result: unknown[]) {
    if (root !== null) {
      postOrderRecursionTree(root.left, result)
      postOrderRecursionTree(root.right, result)
      result.push(root.value)
    }
  }

  const result: unknown[] = []
  postOrderRecursionTree(root, result)
  return result
}

function postOrderTraversal(root: TreeNode) {
  const result: unknown[] = []
  const stack: TreeNode[] = []
  let cur: TreeNode | null = root
  let prev: TreeNode | null = null
  while (cur !== null || stack.length !== 0) {
    while (cur !== null) {
      stack.push(cur)
      cur = cur.left
    }

    cur = stack[stack.length - 1]
    if (cur.right !== null && cur.right !== prev) {
      cur = cur.right
    } else {
      cur = stack.pop() as TreeNode
      result.push(cur.value)
      prev = cur
      cur = null // 这一步用于跳出循环，在stack空了的时候
    }
  }
  return result
}

function post_Order(root: TreeNode) {
  const result: unknown[] = []
  const stack: TreeNode[] = [root]
  let cur: TreeNode | null = null
  let prev: TreeNode | null = null
  while (stack.length !== 0) {
    cur = stack[stack.length - 1]
    if (
      (cur.left === null && cur.right === null) ||
      (prev !== null && (prev === cur.left || prev === cur.right))
    ) {
      result.push(cur.value) //如果当前结点没有孩子结点或者孩子节点都已被访问过
      stack.pop()
      prev = cur
    } else {
      if (cur.right !== null) {
        stack.push(cur.right)
      }
      if (cur.left !== null) {
        stack.push(cur.left)
      }
    }
  }
  return result
}
```

完全二叉树
特点：除了最后一层，其他层的节点都是满的，并且最后一层的节点都是靠左排列





