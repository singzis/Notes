## 线性表与非线性表

- 线性表：数组、队列、栈、链表
- 非线性表：树、堆、图

## 队

特点：
- 先进者先出，这就是典型的“队列”结构
- 支持两个操作：入队enqueue()，放一个数据到队尾；出队dequeue()，从队头取一个元素
- 和栈一样，队列也是一种操作受限的线性表

## 栈

特点：
- 后进者先出，先进者后出，这就是典型的“栈”结构
- 从栈的操作特性来看，是一种“操作受限”的线性表，只允许在端插入和删除数据

为什么需要栈
-  栈是一种操作受限的数据结构，其操作特性用数组和链表均可实现
- 但，任何数据结构都是对特定应用场景的抽象，数组和链表虽然使用起来更加灵活，但却暴露了几乎所有的操作，难免会引发错误操作的风险
- 所以，当某个数据集合只涉及在某端插入和删除数据，且满足后进者先出，先进者后出的操作特性时，我们应该首选栈这种数据结构。

## 缓存

常见的缓存有三种：
- 先进先出策略 FIFO（First In，First Out）
- 最少使用策略 LFU（Least Frequently Used）
- 最近最少使用策略 LRU（Least Recently Used）

### LRU

LRU的算法思路，概括下： 

1.  使用定长链表来保存所有缓存的值，并且最老的值放在链表最后面，
2. 当访问的值在链表中时： 将找到链表中的值删除，并重新在链表头添加该值（保证链表中数值的顺序是从新到旧）
3. 当访问的值不在链表中时： 
	1. 当链表已满：删除链表最后一个值，将要添加的值放在链表头
	2. 当链表未满：直接在链表头添加

## 越界访问，堆栈保护

```c#
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}
```

结果无限循环，因为，数组大小为 3，`a[0]，a[1]，a[2]`，而代码因为书写错误，导致 for 循环的结束条件错写为了 i<=3 而非 i<3，所以当 i=3 时，数组 `a[3]`访问越界

关于越界：
1. 函数体内的局部变量存在栈上，且是连续压栈。在Linux进程的内存布局中，栈区在高地址空间，从高向低增长。变量i和arr在相邻地址，且i比arr的地址大，所以arr越界正好访问到i。当然，前提是i和arr元素同类型，否则那段代码仍是未决行为
2. 例子中死循环的问题跟编译器分配内存和字节对齐有关 数组3个元素 加上一个变量a 。4个整数刚好能满足8字节对齐 所以i的地址恰好跟着a2后面 导致死循环。。如果数组本身有4个元素 则这里不会出现死循环。。因为编译器64位操作系统下 默认会进行8字节对齐 变量i的地址就不紧跟着数组后面了
3. 关于数组越界访问导致死循环的问题，我也动手实践了一下，发现结果和编译器的实现有关，gcc有一个编译选项（-fno-stack-protector）用于关闭堆栈保护功能。默认情况下启动了堆栈保护，不管i声明在前还是在后，i都会在数组之后压栈，只会循环4次；如果关闭堆栈保护功能，则会出现死循环。请参考：
4. js数组是动态调整，不存在越界的问题

## 位运算

```js
a>>b // a的二进制数右移b位，
a>>1 // 表示a除以2

A % B = A & (B - 1) // 除留余数法
```
