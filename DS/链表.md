通过指针将*零散的内存块*串起来的数据结构，具有的结构：
1. 单链表
2. 循环链表
3. 双向链表

## 链表常见操作
- 单链表反转
	- 反向链表思想：从前往后将每个节点的指针反向，即.next内的地址换成前一个节点的，但为了防止后面链表的丢失，在每次换之前需要先创建个指针指向下一个节点
- 链表中环的检测
	- 链表中找环的思想：创建两个指针一个快指针一次走两步一个慢指针一次走一步，若相遇则有环，若先指向null则无环
- 两个有序的链表合并
	- 两个有序链表合并思想：这里用到递归思想。先判断是否有一个链表是空链表，是则返回两一个链表，免得指针指向不知名区域引发程序崩溃。然后每次比较两个链表的头结点，小的值做新链表的头结点，此节点的next指针指向本函数（递归开始，参数是较小值所在链表.next和另一个链表）
- 删除链表倒数第 n 个结点
	- 链表找倒数第k个节点思想：创建两个指针，第一个先走k-1步然后两个在一同走。第一个走到最后时则第二个指针指向倒数第k位置
- 求链表的中间结点
	- 快慢指针，快指针到达尾结点时，慢指针指向中间节点

其他：
- 函数中需要移动链表时，最好新建一个指针来移动，以免更改原始指针位置
- 单链表有带头节点和不带头结点的链表之分，一般做题默认头结点是有值的
- 链表的内存时不连续的，一个节点占一块内存，每块内存中有一块位置（next）存放下一节点的地址（这是单链表为例 
- 哨兵：处理边界问题，比如判空，判头结点、尾结点等
	- 哨兵可以理解为它可以减少特殊情况的判断，比如判空，比如判越界，比如减少链表插入删除中对空链表的判断，比如例子中对i越界的判断。 空与越界可以认为是小概率情况，所以代码每一次操作都走一遍判断，在大部分情况下都会是多余的。 哨兵的巧妙就是提前将这种情况去除，比如给一个哨兵结点，以及将key赋值给数组末元素，让数组遍历不用判断越界也可以因为相等停下来。 使用哨兵的指导思想应该是将小概率需要的判断先提前扼杀，比如提前给他一个值让他不为null，或者提前预设值，或者多态的时候提前给个空实现，然后在每一次操作中不必再判断以增加效率

## 基础代码

### 反转链表

```js
function solution(head) {
  let cur = head
  let prev = null

  while(cur !== null) {
    const next = cur.next
    cur.next = prev
    prev = cur
    cur = next
  }

  return prev
}
```

## 跳表

[参考](https://juejin.cn/post/6844903446475177998)

