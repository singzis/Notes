# docker基础

开源的应用容器引擎，用于开发、发布和运行应用程序。将应用程序和基础架构分离，以便快速交付软件。

## 特点

- 轻量
  - 为何启动快速？如何做到和宿主机共享内核？
  - 当我们请求Docker运行容器时，Docker会在计算机上设置一个资源隔离的环境，然后将打包好的应用程序和关联的文件复制到Namespace内的文件系统中，此时环境的配置就完成了，之后Docker会执行我们预先指定的命令，运行应用程序
- 可移植性

## 核心概念

- build、ship、run（搭建、发布、运行）
- build once, run anywhere（一次搭建，处处运行）
- Docker本身不是容器，是创建容器的工具，应用容器的引擎
- 三个核心：
  - 镜像 Image
    - 只读
  - 容器 Container
    - 是镜像可以运行的实例
    - 一般情况下，隔离于其他容器
    - 由启动或者创建时的配置决定
  - 仓库 Repository

- Docker使用Linux内核和内核功能（例如 `Cgroups` 和 `namespaces`）来分隔进程，以便进程相互独立
- 由于 `Namespace` 和 `Cgroups` 功能仅在 `Linux` 上可用，因此容器无法在其他操作系统上运行。那么 `Docker` 如何在 `macOS` 或 `Windows` 上运行？ `Docker` 实际上使用了一个技巧，并在非 `Linux` 操作系统上安装 `Linux` 虚拟机，然后在虚拟机内运行容器
- 镜像是一个可执行包，其包含运行应用程序所需的代码、运行时、库、环境变量和配置文件，容器是镜像的运行时实例

## 常用命令

| 命令       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| FROM       | - 指定基础镜像，所有构建的镜像都必须有一个基础镜像，且`FROM`命令必须是`Dockerfile`的第一个命令<br />- `FROM <image>[:<tag>] [AS <name>]`从一个指定版本的镜像构建起一个新的镜像名字<br />- 示例：`FROM nginx:1.23.1 AS nginx1231` |
| MAINTAINER | - 镜像维护者的信息<br />- `MAINTAINER <name>`<br />- 示例：`MAINTAINER qunqing` |
| ENV        | - 设置环境变量，有些容器运行时会需要某些环境变量<br />- `ENV <key> <value>` 一次设置一个环境变量<br />- `ENV <key>=<value> <key>=<value> <key>=<value>` 设置多个环境变量<br />- 示例：`ENV JAVA_HOME /usr/java1.8/` |
| RUN        | - 构建镜像时要执行的命令<br />- sheel 格式： `RUN <command>`<br />- exec 格式： `RUN ["executable", "param1", "param2"]` ，注意该格式被解析为JSON数组，所以需要使用双引号<br />- 示例：`RUN /bin/bash -c 'source $HOME/.bashrc; echo $HOME'`<br />- 示例：`RUN ["/bin/bash", "-c", "echo hello"]` |
| ADD        | - 将本地的文件添加复制到容器中去，压缩包会解压，可以访问网络上的文件，会自动下载<br />- `ADD <src> <dest>`<br />- `ADD *.js /app` 添加`js`到容器内`app`文件中 |
| CPPY       | 功能和 `ADD` 一样，只是复制，不会解压或者下载文件            |
| WORKDIR    | - 设置工作目录，设置之后 ，`RUN、CMD、COPY、ADD` 的工作目录都会同步变更<br />- `WORKDIR <path>`<br />- 示例：`WORKDIR /app/test` |
| EXPOSE     | - 暴露对外的端口（容器内部程序的端口，虽然会和宿主机的一样，但是其实是两个端口）<br />- `EXPOSE <port>`<br />- 示例：`EXPOSE 80`<br />- 容器运行时，需要用 `-p` 映射外部端口才能访问到容器内的端口 |
| CMD        | - 启动容器后执行的命令，和 `RUN` 不一样，`RUN` 是在构建镜像是要运行的命令<br />- 当使用 `docker run` 运行容器的时候，这个可以在命令行被覆盖<br />- 示例：`CMD ["executable", "param1", "param2"]` |
| ENTRYPOINT | - 也是执行命令，和 `CMD` 一样，只是这个命令不会被命令行覆盖<br />- `ENTRYPOINT ["executable", "param1", "param2"]`<br />- 示例：`ENTRYPOINT ["donnet", "myapp.dll"]` |
| VOLUME     | - 指定数据持久化的目录，官方语言叫做挂载<br />- `VOLUME /var/log` 指定容器中需要被挂载的目录，会把这个目录映射到宿主机的一个随机目录上，实现数据的持久化和同步。<br />- `VOLUME ["/var/log","/var/test".....]` 指定容器中多个需要被挂载的目录，会把这些目录映射到宿主机的多个随机目录上，实现数据的持久化和同步<br />- `VOLUME /var/data var/log` 指定容器中的 `var/log` 目录挂载到宿主机上的 `/var/data` 目录，这种形式可以手动指定宿主机上的目录 |
| LABEL      | - 为镜像添加元数据，`key-value` 形式<br />- LABEL <key>=<value> <key>=<value> ...<br />- 示例：`LABEL version="1.0" description="这是一个web应用"` |
| USER       | - 指定运行命令时所使用的用户，为了安全和权限起见，根据要执行的命令选择不同用户<br />- USER <user>:[<group>]<br />- 示例：`USER test` |
| ARG        | - 设置构建镜像是要传递的参数<br />- `ARG <name>[=<value>]<br />`<br />- `ARG name=sss` |