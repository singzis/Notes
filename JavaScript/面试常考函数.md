# 面试常考函数
## 构造函数

### 构造函数的返回值

#### 描述

当构造函数返回引用类型的数据时，创建的'实例'将会是该类型的数据，而非该构造函数生成的实例（可以通过 instanceof 来判断，或者在原型上加属性或者方法来判断）

```js
function Car() {
  this.wheel = 4;
  return { wheel: 2 };
}
const car = new Car();
console.log(car.wheel); // 2
```

其他的引用类型数据，比如数组、function、set 或者 map 等都会对构造函数产生影响，实例化对象后会返回该引用类型

```js
function Car1() {
  this.wheel = 4;
  return [2];
}
function Car2() {
  this.wheel = 4;
  return new Set(1);
}
function Car3() {
  this.wheel = 4;
  return new Map(["a", 1]);
}
function Car4() {
  this.wheel = 4;
  return function () {};
}
const car1 = new Car1();
const car2 = new Car2();
const car3 = new Car3();
const car4 = new Car4();
console.log(car1); // [2]
console.log(car2); // Set(1) {1}
console.log(car3); // Map(1) {"a" => 1}
console.log(car4); // ƒ (){}
```

不过，返回值引用的类型，对构造函数是没有任何影响的，实例化对象返回空对象

## generator

补充函数，满足 log 出的值

```js
const teams = [
  { name: "Team 1", members: ["Paul", "Lisa"] },
  { name: "Team 2", members: ["Laura", "Tim"] },
];

function* getMembers(members) {
  for (let i = 0; i < members.length; i++) {
    yield members[i];
  }
}

function* getTeams(teams) {
  for (let i = 0; i < teams.length; i++) {
    // ✨ SOMETHING IS MISSING HERE ✨
    // yield* getMembers(teams[i].members)
  }
}

const obj = getTeams(teams);
obj.next(); // { value: "Paul", done: false }
obj.next(); // { value: "Lisa", done: false }
```

注解：为了遍历 teams 数组中对象的属性 members 中的每一项，我们需要将 `teams[i].members` 传递给 Generator 函数 `getMembers`。Generator 函数返回一个 generator 对象。为了遍历这个 generator 对象中的每一项，我们需要使用 `yield\*`。

如果我们没有写 yield，return yield 或者 return，整个 Generator 函数不会第一时间 return 当我们调用 next 方法。[链接](https://github.com/lydiahallie/javascript-questions/blob/master/zh-CN/README-zh_CN.md)
