# JavaScript

- js数据类型，如何存储

```text
JavaScript 一共有 8 种数据类型，其中有 7 种基本数据类型：Undefined、Null、Boolean、Number、String、Symbol（es6 新增，表示独一无二的值）和 BigInt（es10 新增）；

1种引用数据类型——Object（Object 本质上是由一组无序的名值对组成的）。里面包含 function、Array、Date 等。JavaScript 不支持任何创建自定义类型的机制，而所有值最终都将是上述 8 种数据类型之一。

原始数据类型：直接存储在栈（stack）中，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。

引用数据类型：同时存储在栈（stack）和堆（heap）中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。
```

- null 和 undefined 的区别？

```text
首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。
​
undefined 代表的含义是未定义， null 代表的含义是空对象（其实不是真的对象，请看下面的注意！）。一般变量声明了但还没有定义的时候会返回 undefined，null 主要用于赋值给一些可能会返回对象的变量，作为初始化。
​
其实 null 不是对象，虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。
​
undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。
​
当我们使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。
```

- {}和 [] 的 valueOf 和 toString 的结果是什么？

```text
{} 的 valueOf 结果为 {} ，toString 的结果为 "[object Object]"

[] 的 valueOf 结果为 [] ，toString 的结果为 ""
```

- Javascript 的作用域和作用域链

```text
作用域：作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。
​
作用域链：作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。
​
作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。
​
当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。
​
作用域链的创建过程跟执行上下文的建立有关。
```

- 谈谈你对 this、call、apply 和 bind 的理解

```text
1.  在浏览器里，在全局范围内 this 指向 window 对象；
2.  在函数中，this 永远指向最后调用他的那个对象；
3.  构造函数中，this 指向 new 出来的那个新的对象；
4.  call、apply、bind 中的 this 被强绑定在指定的那个对象上；
5.  箭头函数中 this 比较特殊, 箭头函数 this 为父作用域的 this，不是调用时的 this. 要知道前四种方式, 都是调用时确定, 也就是动态的, 而箭头函数的 this 指向是静态的, 声明的时候就确定了下来；
6.  apply、call、bind 都是 js 给函数内置的一些 API，调用他们可以为函数指定 this 的执行, 同时也可以传参。
```

- JavaScript 原型，原型链？ 有什么特点？

```text
在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个实例对象后，在这个对象的内部 将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说在实例中我们是不应该能够获取到这个值的，但是现在浏览器中都实现了 __proto__ 属性来让我们访问这个属性，但是我们最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，我们可以通过这个方法来获取对象的原型。

当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又 会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是我们新建的对象为什么能够使用 toString() 等方法的原因。Object.prototype 的原型为 null。

特点：
JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与 之相关的对象也会继承这一改变。
```

- 什么是闭包，为什么要用它？

```text
- 闭包就是函数和函数内部能访问到的变量的总和
- 通过闭包，我们能够隐藏变量，还能访问不能访问到的作用域
​
场景
至于闭包的使用场景，其实在日常开发中使用到是非常频繁的
​
- 防抖节流函数
- 定时器回调
- 
​
优点
内部变量是私有的，可以做到隔离作用域，保持数据的不被污染性
​
缺点
因为内部变量是私有的,可以做到隔离作用域，那也就是说垃圾回收机制是无法清理闭包中内部变量的，那最后结果就是内存泄漏
```

- 三种事件模型是什么？

```text
事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。

1.DOM0 级模型：这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。
2.IE 事件模型：在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。
3.DOM2 级事件模型：在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。
```

- js 延迟加载的方式有哪些

```text
js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。
​
- 将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。
- 给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说是顺序执行的，但是在一些浏览器中可能不是这样。
- 给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。
- 动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。
```

- js 的几种模块规范？

```text
js 中现在比较成熟的有四种模块加载方案：
​
- 第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。
- 第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。
- 第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 require.js 的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。
- 第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。
```

- AMD 和 CMD 规范的区别？

```text
它们之间的主要区别有两个方面。
​
1.第一个方面是在模块定义时对依赖的处理不同。AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。
2.第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于 模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD 在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句 的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。
​
// CMD
define(function(require, exports, module) {
  var a = require("./a");
  a.doSomething();
  // 此处略去 100 行
  var b = require("./b"); // 依赖可以就近书写
  b.doSomething();
  // ...
});
​
// AMD 默认推荐
define(["./a", "./b"], function(a, b) {
  // 依赖必须一开始就写好
  a.doSomething();
  // 此处略去 100 行
  b.doSomething();
  // ...
});
```

- ES6 模块与 CommonJS 模块、AMD、CMD 的差异

```text
1、语法上
CommonJS 使用的是 module.exports = {} 导出一个模块对象，require(‘file_path’) 引入模块对象；
ES6使用的是 export 导出指定数据， import 引入具体数据。
​
2、CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用
​
CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。
​
ES6 Modules 的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6的import 有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。
​
3、CommonJS 模块是运行时加载，ES6 模块是编译时加载
​
运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。
​
编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”
​
PS：CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成
```

- 简单介绍一下 V8 引擎的垃圾回收机制

```text
v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。
​
新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。
​
新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：
​
（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。
​
（2）如果对象不存活，则释放对象的空间。
​
（3）最后将 From 空间和 To 空间角色进行交换。
​
新生代对象晋升到老生代有两个条件：
​
（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。
​
（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。
​
老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。
​
由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。
```

- 哪些操作会造成内存泄漏？

```text
1. 意外的全局变量
2. 被遗忘的计时器或回调函数
3. 脱离 DOM 的引用
4. 闭包
```

- ES6有哪些新特性？

```text
1. 块级作用域与常量（let和const）：引入了块级作用域，使用`let`关键字声明变量，以及使用`const`关键字声明常量，使得变量和常量的作用域更加清晰可控。

2. 箭头函数：使用箭头函数语法`=>`可以更简洁地定义函数，并且自动绑定上下文，避免了传统函数中`this`指向的困扰。

3. 默认参数：函数参数可以设置默认值，当参数没有传入或传入的值为`undefined`时，将使用默认值。

4. 模板字符串：使用反引号（`）包裹字符串，可以在其中使用变量和表达式，还支持多行字符串和字符串插值。

5. 解构赋值：可以从数组或对象中快速提取值并赋给变量，简化了变量的声明和赋值过程。

6. 扩展运算符和剩余参数：使用三个点（...）可以将数组或对象展开为独立的元素，也可以将多个参数收集为数组。

7. 类与模块：引入了类的概念，可以使用`class`关键字定义类，并支持构造函数、继承等面向对象的特性。同时，ES6还引入了模块化的语法，可以使用`export`和`import`关键字导出和导入模块。

8. 箭头函数、类、模块等语法糖：ES6引入了许多语法糖，使得代码更加简洁、易读，提高了开发效率。

9. Promise和异步编程：ES6引入了Promise对象，提供了更好的异步编程方式，解决了回调地狱的问题。同时，ES6还新增了`async/await`语法糖，使得异步代码看起来更像同步代码，更易于理解和维护。

10. 数组和对象的增强：ES6提供了许多对数组和对象操作的增强功能，如数组的扩展方法（map、filter、reduce等）、对象的属性简写和计算属性名等。
```

- 事件循环

```text
在JavaScript中，事件循环是一种机制，用于管理和执行异步代码。它确保了代码以非阻塞的方式运行，并处理事件、回调函数和其他异步操作。

事件循环的基本原理是，JavaScript引擎在执行同步代码时，会将异步代码（例如回调函数、定时器等）放入任务队列（Task Queue）中。一旦主线程空闲，事件循环就会将队列中的任务取出并执行。

事件循环由以下几个主要组成部分组成：

1. 调用栈（Call Stack）：用于管理执行上下文的栈结构。同步代码按顺序在调用栈中执行。
2. 任务队列（Task Queue）：用于存储待执行的异步任务。任务队列分为不同的类型，例如宏任务（macrotask）和微任务（microtask）。
3. 事件触发线程：负责监听事件，当事件发生时将回调函数添加到任务队列中。
4. 事件循环线程：负责不断地将任务队列中的任务取出并执行。

事件循环的基本流程如下：

1. 执行全局同步代码，将相关函数添加到调用栈中执行。
2. 遇到异步代码，将其移出主线程，放入任务队列中等待执行。
3. 当调用栈为空时，事件循环会检查任务队列。
4. 如果任务队列中有待执行的微任务，事件循环会优先执行微任务，直到微任务队列为空。
5. 如果微任务队列为空，事件循环会从宏任务队列中取出一个任务，放入调用栈中执行。
6. 执行完当前宏任务后，再次检查微任务队列，执行所有微任务。
7. 重复步骤5和步骤6，直到任务队列和微任务队列都为空。

这个过程会不断循环，以确保异步代码得到及时执行，并保持应用程序的响应性。
```
