1.  了解数据结构和算法的基本概念。
2.  学习不同类型的数据结构，比如数组、链表、哈希表、栈和队列等。
3.  学习常见的算法，比如排序算法、搜索算法和图算法。
4.  练习实现不同的数据结构和算法。
5.  学会分析算法的时间复杂度和空间复杂度。
6.  不断学习新的数据结构和算法，并不断练习应用它们。

## 线性表与非线性表

- 线性表：数组、队列、栈、链表
- 非线性表：树、堆、图

## 缓存

常见的缓存有三种：
- 先进先出策略 FIFO（First In，First Out）
- 最少使用策略 LFU（Least Frequently Used）
- 最近最少使用策略 LRU（Least Recently Used）

### LRU

LRU的算法思路，概括下： 

1.  使用定长链表来保存所有缓存的值，并且最老的值放在链表最后面，
2. 当访问的值在链表中时： 将找到链表中的值删除，并重新在链表头添加该值（保证链表中数值的顺序是从新到旧）
3. 当访问的值不在链表中时： 
	1. 当链表已满：删除链表最后一个值，将要添加的值放在链表头
	2. 当链表未满：直接在链表头添加

## 越界访问，堆栈保护

```c#
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}
```

结果无限循环，因为，数组大小为 3，`a[0]，a[1]，a[2]`，而代码因为书写错误，导致 for 循环的结束条件错写为了 i<=3 而非 i<3，所以当 i=3 时，数组 `a[3]`访问越界

关于越界：
1. 函数体内的局部变量存在栈上，且是连续压栈。在Linux进程的内存布局中，栈区在高地址空间，从高向低增长。变量i和arr在相邻地址，且i比arr的地址大，所以arr越界正好访问到i。当然，前提是i和arr元素同类型，否则那段代码仍是未决行为
2. 例子中死循环的问题跟编译器分配内存和字节对齐有关 数组3个元素 加上一个变量a 。4个整数刚好能满足8字节对齐 所以i的地址恰好跟着a2后面 导致死循环。。如果数组本身有4个元素 则这里不会出现死循环。。因为编译器64位操作系统下 默认会进行8字节对齐 变量i的地址就不紧跟着数组后面了
3. 关于数组越界访问导致死循环的问题，我也动手实践了一下，发现结果和编译器的实现有关，gcc有一个编译选项（-fno-stack-protector）用于关闭堆栈保护功能。默认情况下启动了堆栈保护，不管i声明在前还是在后，i都会在数组之后压栈，只会循环4次；如果关闭堆栈保护功能，则会出现死循环。请参考：
4. js数组是动态调整，不存在越界的问题

## 位运算

```js
a>>b // a的二进制数右移b位，
a>>1 // 表示a除以2

A % B = A & (B - 1) // 除留余数法
```

## 斐波那契数

```ts
// 动态规划
function fibonacci(n) {
  // 初始化数组并设置前两项的值
  let fib = [0, 1];

  // 从下标 2 开始遍历数组
  for (let i = 2; i <= n; i++) {
    // 计算当前项的值
    fib[i] = fib[i - 1] + fib[i - 2];
  }

  // 返回第 n 项的值
  return fib[n];
}

// 递归
function fibonacci(n: number) {
    if (n <= 0) {
        return 0
    }

    if (n === 1) {
        return 1
    }

    return fibonacci(n - 1) + fibonacci(n - 2)
}

// 调用函数并输出结果
console.log(fibonacci(10)); // 输出 55
```

## 杨辉三角

```ts
function pascalTriangle(n: number) {
    // n 为层数
    // 创建一个空的2维数组，n行n列
    let triangle = new Array(n)
    for (let k = 0; k < n; k++) {
        triangle[k] = (new Array(k + 1))
    }

    for (let i = 0; i < n; i++) {
        for (let j = 0; j < i + 1; j++) {
            // 位于第一个或者最后一个，则值为1
            if (j === 0 || j === i) {
                triangle[i][j] = 1
            } else {
                // 回溯法填充，当前值为上一行当前列和前一列的和
                triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j]
            }
        }
    }

    return triangle
}
```