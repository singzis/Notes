Chrome常驻进程包括：
- 网络进程：处理网络请求和响应
- 渲染进程：解析html、css和js，渲染页面
- 插件进程：管理浏览器插件
- GUI进程：绘制浏览器界面，比如加载动画、状态栏、标签开关动画等
- 浏览器进程：管理所有浏览器状态和各个进程，调度进程间工作，与其他进程通过ICP通信

### 沙箱机制

插件进程和渲染进程采用沙箱机制，主要是防止插件和网页访问电脑系统，对系统磁盘进行读写操作，造成不好的影响

### 渲染进程

chrome只会启动一个浏览器进程，一个标签页开启一个渲染进程，每个渲染进程都有一个id，由浏览器进程统一管理，渲染进程发起起源请求时，是把该请求交给浏览器进程去处理的，然后通过id识别是哪个渲染进程发起的请求，然后把响应给到对应的渲染进程

渲染进程有两个主要线程：渲染线程、主线程。渲染线程与浏览器通信时，会讲消息发给主线程。js在读取cookie时，是会阻塞渲染线程的，因为需要通过主线程告诉浏览器进程去获取cookie，期间主线程将对收到的所有消息进行排队，直到找到正确的响应

共享渲染进程：正常情况下，一个标签页使用一个渲染进程，但如果满足以下条件，则能共享渲染进程：
1. 同一站点：协议和根域名相同即可，例如https://blog.xx.com和https://xx.com:1024
2. 同一浏览上下文组：通过a标签（未设置rel="noopener noreferrer"）或者window.open打开的新标签页，都能通过opener建立连接（原标签页可以通过new_opener访问新标签页的window，新标签页可以通过window.opener访问原标签页的window），按规范，把这种具有连接的标签页称为浏览上下文组

浏览上下文：通常情况下，我们把一个标签页所包含的内容，诸如 window 对象，历史记录，滚动条位置等信息称为浏览上下文。这些通过脚本相互连接起来的浏览上下文就是浏览上下文组

针对iframe，如果iframe与父标签页同源，则与父标签页共享同一个渲染进程，否则看是否有同源的iframe，有的话则运行在相同的进程中，否则新建渲染进程

#### 渲染流程

[流程](obsidian://open?vault=Notes&file=web%2F%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B)

### 浏览器进程

cookie由浏览器进程处理，因为同域是共享cookie的

内存不足的情况下，浏览器会对隐形标签释放内存，数据改为用磁盘存储，目的是为了让顶层标签享用更多的内存，在隐形标签被激活时，会交换回来，磁盘换到内存，如果电脑本身内存很足，不会有这个情况

